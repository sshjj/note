# 为什么要使用索引？
1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2. 可以大大加快 数据的检索速度（大大减少的检索的数据量）, 这也是创建索引的最主要的原因。
3. 帮助服务器避免排序和临时表。
4. 将随机IO变为顺序IO
5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

# 索引这么多优点，为什么不对表中的每一个列创建一个索引呢？
1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

# Mysql索引主要使用的两种数据结构
## 哈希索引
对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。
## BTree索引
B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合矮矮胖胖(均衡)的结构)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。

B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构。
要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度

# MyISAM和InnoDB实现BTree索引方式的区别
## MyISAM
B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
## InnoDB
其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 

# 覆盖索引介绍
## 什么是覆盖索引
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
## 覆盖索引使用实例
现在我创建了索引(username,age)，我们执行下面的 sql 语句
```
select username , age from user where username = 'Java' and age = 22
```
在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表。

# 选择索引和编写利用这些索引的查询的3个原则
1. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。
2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。
3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就 不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访 问是很慢的。

# 为什么索引能提高查询速度
## 先从 MySQL 的基本存储结构说起
MySQL的基本存储结构是页(记录都存在页里边)：
1. 各个数据页可以组成一个双向链表
2. 每个数据页中的记录又可以组成一个单向链表
   1. 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
   2. 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：
1. 定位到记录所在的页：需要遍历双向链表，找到所在的页
2. 从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了
很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。
## 使用索引之后
索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：

很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）

其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

# 关于索引其他重要的内容补充
## 最左前缀原则
MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：
```
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
```
这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name ＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。
## 注意避免冗余索引
冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。
## Mysql如何为表字段添加索引？？？
1. 添加PRIMARY KEY（主键索引）
```
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```
2. 添加UNIQUE(唯一索引)
```
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```
3. 添加INDEX(普通索引)
```
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```
4. 添加FULLTEXT(全文索引)
```
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
```
5. 添加多列索引
```
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

# 索引 
到这⾥可以总结出来，Mysql选⽤B+树这种数据结构作为索引，可以提⾼查询索引时的磁盘IO效率，并且可以提⾼范围查询的效率，并且B+树⾥的元素也是有序的。
* 那么，⼀个B+树的节点中到底存多少个元素最合适你有了解过么？
B+树中⼀个节点为⼀⻚或⻚的倍数最为合适。
因为如果⼀个节点的⼤⼩⼩于1⻚，那么读取这个节点的时候其实也会读出1⻚，造成资源的浪费。
如果⼀个节点的⼤⼩⼤于1⻚，⽐如1.2⻚，那么读取这个节点的时候会读出2⻚，也会造成资源的浪
费。
所以为了不造成浪费，所以最后把⼀个节点的⼤⼩控制在1⻚、2⻚、3⻚、4⻚等倍数⻚⼤⼩最为合适。

* 你提到了⻚的概念，能跟我简单说⼀下么？
⾸先Mysql的基本存储结构是⻚(记录都存在⻚⾥边)：
* 各个数据⻚可以组成⼀个双向链表
* ⽽每个数据⻚中的记录⼜可以组成⼀个单向链表
* 每个数据⻚都会为存储在它⾥边⼉的记录⽣成⼀个⻚⽬录，在通过主键查找某条记录的时候可以在⻚⽬录中使⽤⼆分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
* 以其他列(⾮主键)作为搜索条件：只能从最⼩记录开始依次遍历单链表中的每条记录。
所以说，如果我们写 select * from user where username='丙丙'这样没有进⾏任何优化的sql语句，默认会这样做：
* 定位到记录所在的⻚
   * 需要遍历双向链表，找到所在的⻚
* 从所在的⻚内中查找相应的记录
   * 由于不是根据主键查询，只能遍历所在⻚的单链表了
很明显，在数据量很⼤的情况下这样查找会很慢！看起来跟回表有点点像。

* 哦？回表你聊⼀下。
回表⼤概就是我们有个主键为ID的索引，和⼀个普通name字段的索引，我们在普通字段上搜索：
select * from table where name = '丙丙'
执⾏的流程是先查询到name索引上的“丙丙”，然后找到他的id是2，最后去主键索引，找到id为2对应的值。
回到主键索引树搜索的过程，就是回表。不过也有⽅法避免回表，那就是覆盖索引。

* 哦？那你再跟我聊⼀下覆盖索引呗？
这个其实⽐较好理解，刚才我们是 select * ，查询所有的，我们如果只查询ID那，其实在Name字段的索引上就已经有了，那就不需要回表了。
覆盖索引可以减少树的搜索次数，提升性能，他也是我们在实际开发过程中经常⽤来优化查询效率的⼿段。
很多联合索引的建⽴，就是为了⽀持覆盖索引，特定的业务能极⼤的提升效率。

* 索引的最左匹配原则知道么？
最左匹配原则：
- 索引可以简单如⼀个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能⽤于查找key是否存在（相等），遇到范围查询 (>、<、between、like左匹配)等就不能进⼀步匹配了，后续退化为线性查找。
- 因此，列的排列顺序决定了可命中索引的列数。
例子：如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c>3 and d=4，则会在每个节点依次命中a、b、c，
⽆法命中d。(c已经是范围查询了，d肯定是排不了序了)

* 总结
索引在数据库中是⼀个⾮常重要的知识点！
上⾯谈的其实就是索引最基本的东⻄，N叉树，跳表、LSM我都没讲，同时要创建出好的索引要顾及到很多的⽅⾯：

+ 最左前缀匹配原则。这是⾮常重要、⾮常重要、⾮常重要（重要的事情说三遍）的原则，MySQL会⼀直向右匹配直到遇到范围查询 （>,<,BETWEEN,LIKE）就停⽌匹配。
+ 尽量选择区分度⾼的列作为索引，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的⽐率，⽐率越⼤我们扫描的记录数就越少。
+ 索引列不能参与计算，尽量保持列“⼲净”。⽐如， FROM_UNIXTIME(create_time)='2016-06-06'就不能使⽤索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进⾏检索时，需要把所有元素都应⽤函数才能⽐较，显然这样的代价太⼤。所以语句要写成 ：create_time=UNIX_TIMESTAMP('2016-06-06')。
+ 尽可能的扩展索引，不要新建⽴索引。⽐如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
+ 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执⾏SQL时，MySQL只能使⽤⼀个索引，会从多个单列索引中选择⼀个限制最为严格的索引(经指正，在MySQL5.0以后的版本中，有“合并索引”的策略，翻看了《⾼性能MySQL 第三版》，书作者认为：还是应该建⽴起⽐较好的索引，⽽不应该依赖于“合并索引”这么⼀个策略)。 
+ “合并索引”策略简单来讲，就是使⽤多个单列索引，然后将这些结果⽤“union或者and”来合并起来