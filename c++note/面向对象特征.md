# 封装
封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息藏。

# 继承
面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新写原来的类的情况下对这些功能进行扩展。
通过继承创建的新类称为“子类”或“派生类”。
被继承的类称为“基类”、“父类”或“超类”。
继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。
在某些 OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。
继承概念的实现方式有三类：实现继承、接口继承和可视继承。
Ø         实现继承是指使用基类的属性和方法而无需额外编码的能力；
Ø         接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；
Ø         可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，创建抽象类时，请使用关键字 Interface 而不是 Class。
OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。

# 多态
## 初探多态性
***
在面向对象方法中，所谓多态性就是不同对象收到相同消息，产生不同的行为。在C++程序设计中，多态性是指用一个名字定义不同的函数，这些函数执行不同但又类似的操作，这样就可以用同一个函数名调用不同内容的函数。换言之，可以用同样的接口访问功能不同的函数，从而实现“一个接口，多种方法”。

事实上，在程序设计中经常会使用到多态性。最简单的例子就是运算符了，例如我们使用运算符+，就可以实现整型数、浮点数、双精度类型之间的加法运算，这三种类型的加法操作其实是互不相同的，是由不同内容的函数实现的。这个例子就是使用了多态的特征。

在C++中，多态性的实现和联编（也称绑定）这一概念有关。一个源程序经过编译、链接，成为可执行文件的过程是把可执行代码联编（或称装配）在一起的过程。其中在运行之前就完成的联编成为静态联编（前期联编）；而在程序运行之时才完成的联编叫动态联编（后期联编）。

静态联编支持的多态性称为编译时多态性（静态多态性）。在C++中，编译时多态性是通过函数重载和模板实现的。利用函数重载机制，在调用同名函数时，编译系统会根据实参的具体情况确定索要调用的是哪个函数。

动态联编所支持的多态性称为运行时多态（动态多态）。在C++中，运行时多态性是通过虚函数来实现的。

再举一个通俗易懂的例子：比如买票这个行为，普通人买是全价；学生买是半价票等。
***
## 多态的定义和实现
### 多态定义构成条件

多态是在不同继承关系的类对象，去调用同一函数，产生了不同的行为。比如Student继承了Person.Person买票就是全价，而Student买票就是半价。

那么在继承中要构成多态还需要两个条件：
1. 调用函数的对象必须是指针或者引用。
2. 被调用的函数必须是虚函数，且完成了虚函数的重写。

什么是虚函数？
虚函数：在类的成员函数前加virtual关键字。
```
class Person
{
public:
	virtual void BuyTicket()
	{
		cout << "买票-全价" << endl;
	}
};
```
什么是虚函数的重写？
虚函数的重写：派生类中有一个跟基类的完全相同的虚函数，我们就称子类的虚函数重写了基类的虚函数。“完全相同”是指：函数名、参数、返回值都相同。另外，虚函数的重写也叫做虚函数的覆盖。
```
#include <iostream>
#include <stdlib.h>

using namespace std;

class Person
{
public:
	virtual void BuyTicket()
	{
		cout << "买票-全价" << endl;
	}
};

class Student : public Person
{
public:
	virtual void BuyTicket(){
		cout << "买票-半价" << endl;
	}
};

void Func(Person& p)
{
	p.BuyTicket();
}

int main()
{
	Person ps;
	Student st;

	Func(ps);
	Func(st);

	system("pause");
	return 0;
}
```
不规范的重写行为

在派生类中重写的成员函数可以不加virtual关键字，也是构成重写，因为继承后基类的虚函数被继承下来，在派生类中依旧保持虚函数的属性，我们只是重写了它。这是非常不规范的，在平时尽量不要这样使用。

注意：若子类中的函数有virtual修饰，而父类中没有，则会构成函数隐藏。

基类中的析构函数如果是虚函数，那么派生类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor，这也说明基类的析构函数最好写成虚函数。

这里贴一个链接，专门解释了为什么基类的析构函数最好写成虚函数：https://blog.csdn.net/komtao520/article/details/82424468

接口继承与实现继承
普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以，如果不实现多态，不要把函数定义成虚函数。