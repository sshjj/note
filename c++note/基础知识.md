# 引用
## 引用通常用于函数参数列表和函数返回值。
把引用作为参数	| C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。
把引用作为返回值 | 	可以从 C++ 函数中返回引用，就像返回其他数据类型一样。
## C++ 引用 vs 指针
引用很容易与指针混淆，它们之间有三个主要的不同：
* 不存在空引用。引用必须连接到一块合法的内存。
* 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
* 引用必须在创建时被初始化。指针可以在任何时间被初始化。
# C++继承
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。

继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。

一个派生类继承了所有的基类方法，但下列情况除外：
* 基类的构造函数、析构函数和拷贝构造函数。
* 基类的重载运算符。
* 基类的友元函数。

# 模板
可以使函数或类在对应不同的型别的时候正常工作，而无需为每一个型别都写一份代码
## 模板实例化
template<typename T >struct Object{ };
## 函数模板
* 函数模板是参数化的一族函数
* 通过函数模板，可以玩定义一系列函数，这些函数都基于同一套代码，但是可以作用在不同型别的参数上

template<typename T >
inline T Max(const T&a,const T&b){
    return (a>b)?a:b;
}
不同的型别，都从模板实例化出不同的函数实体
### 实例化
* 用具体型别代替模板参数T的过程叫实例化，从而产生了一个模板实例
* 实例化过程由编译器自动触发，不需要额外去请求模板实例化
模板被编译了两次
1. 没有实例化之前，检查模板代码本身是否有语法错误
2. 实例化期间，检查对模板代码的调用是否合法 
### 参数推导
不允许自动类型转换
Max(static_cast<double>(1),2.0);
Max<double>(1,2.0)
### 函数模板也可以重载
* 非模板函数可以和同名的模板函数共存
* 编译器通过函数模板参数推导来决定使用调用哪个重载
## C++类模板
* 类也可以通过参数泛化，从而可以构建出一族不同型别的类实例（对象）
* 类模板实参可以是某一型别或常量
## 例子
const std::size_t DefaultStackSize = 1024;
template<typename T,std::size_t n = DefaultStackSize>class Stack{
public:
    void Push(const T const& element);
    int Pop(T& element);
    int Top(T& element)const;
    Stack(Stack<T,n>const&);      //拷贝构造
    Stack<T>&operator=(Stack<T,n>const&); //重载=运算符
private:
    std::vector<T> m_Members;
    std::size_t m_nMaxSize = n;
}
### 定义成员函数 
template<typename T,std::size_t nMaxSize>
void Stack<T,nMaxSize>::Push(const T const& element){
    if(m_Members.size()>=m_nMaxSize){
        return;
    }
    m_Members.push_back(element);
}
## 类模板特化
* 声明一个带template<>的类，即空参数列表
* 在类名称后面紧跟的尖括号中显示指明类别，例如：
template<>
class Stack<std::wstring>{
    ...
}

template<> class Stack<std::wstring>{{
public: 
    void SetStackSize(const std::size_t n){m_nMaxSize = n;}       //添加新的成员函数
    std::size_t CurrentSize() const{return m_Members.size();}

    void Push(const std::wstring const& element);
    int Pop(std::wstring& element);
    int GetTop(std::wstring& element)const;
private:
    std::size_t m_nMaxSize;
    std::list<std::wstring>m_Members;    //采用list作为Stack的内部实现，取代了主模板中用vector实现的方式
}}

# c++ 操作符重载
* 关键字operator定义了一种特殊的函数，该函数的行为是将操作符应用于某一特定的型别，使之能通过该操作符进行操作。
* 操作符重载给出了操作符的不同含义
* 编译器通过具体型别来识别某个操作符在该型别上的意义
* 本质上operator重载就是函数
## 一般规律
* 不可以定义一种新的操作符
* 对于内置型别，不能再用operator重载
* 操作符重载的两种情况：
   * 非静态成员函数
   * 静态全局函数(如果该全局函数需要访问类的private或protected成员，须声明为friend成员)