# 引用
## 引用通常用于函数参数列表和函数返回值。
把引用作为参数	| C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。
把引用作为返回值 | 	可以从 C++ 函数中返回引用，就像返回其他数据类型一样。
## C++ 引用 vs 指针
引用很容易与指针混淆，它们之间有三个主要的不同：
* 不存在空引用。引用必须连接到一块合法的内存。
* 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
* 引用必须在创建时被初始化。指针可以在任何时间被初始化。
# C++继承
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行时间的效果。

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。

继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。

一个派生类继承了所有的基类方法，但下列情况除外：
* 基类的构造函数、析构函数和拷贝构造函数。
* 基类的重载运算符。
* 基类的友元函数。

# 模板
可以使函数或类在对应不同的型别的时候正常工作，而无需为每一个型别都写一份代码
## 模板实例化
template<typename T >struct Object{ };
## 函数模板
* 函数模板是参数化的一族函数
* 通过函数模板，可以玩定义一系列函数，这些函数都基于同一套代码，但是可以作用在不同型别的参数上

template<typename T >
inline T Max(const T&a,const T&b){
    return (a>b)?a:b;
}
不同的型别，都从模板实例化出不同的函数实体
### 实例化
* 用具体型别代替模板参数T的过程叫实例化，从而产生了一个模板实例
* 实例化过程由编译器自动触发，不需要额外去请求模板实例化
模板被编译了两次
1. 没有实例化之前，检查模板代码本身是否有语法错误
2. 实例化期间，检查对模板代码的调用是否合法 
### 参数推导
不允许自动类型转换
Max(static_cast<double>(1),2.0);
Max<double>(1,2.0)
### 函数模板也可以重载
* 非模板函数可以和同名的模板函数共存
* 编译器通过函数模板参数推导来决定使用调用哪个重载
## C++类模板
* 类也可以通过参数泛化，从而可以构建出一族不同型别的类实例（对象）
* 类模板实参可以是某一型别或常量
## 例子
const std::size_t DefaultStackSize = 1024;
template<typename T,std::size_t n = DefaultStackSize>class Stack{
public:
    void Push(const T const& element);
    int Pop(T& element);
    int Top(T& element)const;
    Stack(Stack<T,n>const&);      //拷贝构造
    Stack<T>&operator=(Stack<T,n>const&); //重载=运算符
private:
    std::vector<T> m_Members;
    std::size_t m_nMaxSize = n;
}
### 定义成员函数 
template<typename T,std::size_t nMaxSize>
void Stack<T,nMaxSize>::Push(const T const& element){
    if(m_Members.size()>=m_nMaxSize){
        return;
    }
    m_Members.push_back(element);
}
## 类模板特化
* 声明一个带template<>的类，即空参数列表
* 在类名称后面紧跟的尖括号中显示指明类别，例如：
template<>
class Stack<std::wstring>{
    ...
}

template<> class Stack<std::wstring>{{
public: 
    void SetStackSize(const std::size_t n){m_nMaxSize = n;}       //添加新的成员函数
    std::size_t CurrentSize() const{return m_Members.size();}

    void Push(const std::wstring const& element);
    int Pop(std::wstring& element);
    int GetTop(std::wstring& element)const;
private:
    std::size_t m_nMaxSize;
    std::list<std::wstring>m_Members;    //采用list作为Stack的内部实现，取代了主模板中用vector实现的方式
}}

# c++ 操作符重载
* 关键字operator定义了一种特殊的函数，该函数的行为是将操作符应用于某一特定的型别，使之能通过该操作符进行操作。
* 操作符重载给出了操作符的不同含义
* 编译器通过具体型别来识别某个操作符在该型别上的意义
* 本质上operator重载就是函数
## 一般规律
* 不可以定义一种新的操作符
* 对于内置型别，不能再用operator重载
* 操作符重载的两种情况：
   * 非静态成员函数
   * 静态全局函数(如果该全局函数需要访问类的private或protected成员，须声明为friend成员)

# 智能指针
## unique_ptr
1. 特性
   * 任意时刻unique_ptr只能指向某一个对象，指针销毁时，指向的对象也会被删除（通过内置删除器，通过调用析构函数实现删除对象）

   * 禁止拷贝和赋值（底层实现拷贝构造函数和复制构造函数 = delete），可以使用std::move()、unique_ptr.reset(...) 转移对象指针控制权。

（由1决定，指针发生了拷贝就违反了第一条）

2. 怎么实现禁止拷贝构造和赋值构造？
拷贝构造 和 赋值符‘=’ 对应函数 被删除了，所以用不了。

# C++11右值引用
## C++左值和右值
在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。
值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 "read value"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。
通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。
1. 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：
int a = 5;
5 = a; //错误，5 不能为左值
其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：
int b = 10; // b 是一个左值
a = b; // a、b 都是左值，只不过将 b 可以当做右值使用
2. 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。
以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &a 和 &b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 
## C++右值引用
前面提到，其实 C++98/03 标准中就有引用，使用 "&" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：
int num = 10;
int &b = num; //正确
int &c = 10; //错误
我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。
为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 "&&" 表示。
需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;
和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：
int && a = 10;
a = 100;
cout << a << endl;
程序输出结果为 100。
另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：
const int&& a = 10;//编译器不会报错
但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。
## C++11移动语义是什么
如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。通过《C++拷贝构造函数》一节的学习我们知道，拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。
那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。
## C++移动构造函数（移动语义的具体实现）
所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。
* 事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。
可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。
当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。
在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。
默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。
## C++11 move()函数：将左值强制转换为右值
它的功能很简单，就是将某个左值强制转化为右值。
基于 move() 函数特殊的功能，其常用于实现移动语义。
## C++11完美转发及实现方法详解
首先解释一下什么是完美转发，它指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。
举个例子：
template<typename T>
void function(T t) {
    otherdef(t);
}
如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。

C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。

仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：
template <typename T>
void function(T&& t) {
    otherdef(t);
}
此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：
读者只需要知道，在实现完美转发时，只要函数模板的参数类型为 T&&，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。

通过将函数模板的形参类型设置为 T&&，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？
引入了一个模板函数 forword<T>()，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：

//实现完美转发的函数模板
template <typename T>
void function(T&& t) {
    otherdef(forward<T>(t));
}
forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。